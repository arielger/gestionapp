// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgres"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --------------------------------------

model Organization {
  id             Int              @id @default(autoincrement())
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  name           String
  memberships    Membership[]
  Property       Property[]
  RealStateOwner RealStateOwner[]
  Tenant         Tenant[]
  Contract       Contract[]
  Activity       Activity[]
  Payment        Payment[]
}

model Membership {
  id Int @id @default(autoincrement())

  organization   Organization @relation(fields: [organizationId], references: [id])
  organizationId Int

  user   User? @relation(fields: [userId], references: [id])
  userId Int?

  // TODO: Review when implementing invitations
  // // When the user joins, we will clear out the name and email and set the user.
  // invitedName  String?
  // invitedEmail String?

  @@unique([organizationId, userId])
}

model User {
  id             Int      @id @default(autoincrement())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  name           String?
  email          String   @unique
  hashedPassword String?
  role           String   @default("USER")

  tokens      Token[]
  sessions    Session[]
  memberships Membership[]
}

model Session {
  id                 Int       @id @default(autoincrement())
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  expiresAt          DateTime?
  handle             String    @unique
  hashedSessionToken String?
  antiCSRFToken      String?
  publicData         String?
  privateData        String?

  user   User? @relation(fields: [userId], references: [id])
  userId Int?
}

model Token {
  id          Int       @id @default(autoincrement())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  hashedToken String
  type        TokenType
  expiresAt   DateTime
  sentTo      String

  user   User @relation(fields: [userId], references: [id])
  userId Int

  @@unique([hashedToken, type])
}

enum TokenType {
  RESET_PASSWORD
}

model Property {
  id             Int              @id @default(autoincrement())
  address        String
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  owners         RealStateOwner[]
  Contract       Contract[]
  organization   Organization     @relation(fields: [organizationId], references: [id])
  organizationId Int
}

// TODO: Check if it makes sense to merge Tenant and RealStateOwner
model RealStateOwner {
  id             Int          @id @default(autoincrement())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  firstName      String
  lastName       String
  properties     Property[]
  contracts      Contract[]
  organization   Organization @relation(fields: [organizationId], references: [id])
  organizationId Int
  email          String?
}

model Tenant {
  id             Int          @id @default(autoincrement())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  firstName      String
  lastName       String
  contracts      Contract[]
  organization   Organization @relation(fields: [organizationId], references: [id])
  organizationId Int
  email          String?
}

model Contract {
  id             Int              @id @default(autoincrement())
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  owners         RealStateOwner[]
  tenants        Tenant[]
  property       Property         @relation(fields: [propertyId], references: [id])
  propertyId     Int
  organization   Organization     @relation(fields: [organizationId], references: [id])
  organizationId Int
  startDate      DateTime
  endDate        DateTime
  rentAmount     Float
  activities     Activity[]
  Payment        Payment[]
}

enum ActivityType {
  RENT
  // used for activities with custom title / information
  CUSTOM
}

enum ActivityPersonType {
  OWNER
  TENANT
}

model Activity {
  id              Int                    @id @default(autoincrement())
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  date            DateTime               @default(now())
  organization    Organization           @relation(fields: [organizationId], references: [id])
  organizationId  Int
  amount          Float
  isDebit         Boolean
  type            ActivityType
  contract        Contract               @relation(fields: [contractId], references: [id])
  contractId      Int
  assignedTo      ActivityPersonType
  customDetailsId Int?                   @unique
  customDetails   ActivityCustomDetails?
  payment         Payment?               @relation(fields: [paymentId], references: [id])
  paymentId       Int?

  // Define if credit activity is paying a debit activity
  activityToPay   Activity?  @relation("ActivityToPay", fields: [activityToPayId], references: [id])
  activityToPayId Int?
  paidBy          Activity[] @relation("ActivityToPay")
}

model ActivityCustomDetails {
  id         Int      @id @default(autoincrement())
  activity   Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)
  activityId Int      @unique
  title      String
}

model Payment {
  id             Int          @id @default(autoincrement())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  date           DateTime
  items          Activity[]
  contract       Contract     @relation(fields: [contractId], references: [id])
  contractId     Int
  organization   Organization @relation(fields: [organizationId], references: [id])
  organizationId Int
}
